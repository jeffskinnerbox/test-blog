################################## Junk ########################################
* [Sleepy Pi 2](https://spellfoundry.com/product/sleepy-pi-2/)
* [Installing the Arduino IDE including ESP8266 support](http://www.sensorsiot.org/installing-the-arduino-ide-including-esp8266-support/)
* [Build An Internet-Connected Alarm Clock With An Arduino](http://www.lifehacker.com.au/2014/08/build-an-internet-connected-alarm-clock-with-an-arduino/)
* [Build a clock for your entertainment center with a Raspberry Pi](https://opensource.com/article/17/7/raspberry-pi-clock?utm_medium=Email&utm_campaign=editorspicks&sc_cid=701f2000000tpYdAAI)
* [Analog VU Meter - I2C OLED SH1106 - OLEDMeter Animation](https://forum.arduino.cc/index.php?PHPSESSID=u75qua3pd504eg6p24m9bcpal0&topic=403234.msg2773633#msg2773633)
* [Arduino Clock Jots Down The Time, In UV](https://hackaday.com/2018/03/22/arduino-clock-jots-down-the-time-in-uv/)
* [Analog Meters Become a Clock for Father’s Day](https://hackaday.com/2018/06/22/analog-meters-become-a-clock-for-fathers-day/)
* [Old LED Light Bulbs Give Up Filaments for Spider Web Clock](https://hackaday.com/2018/08/01/old-led-light-bulbs-give-up-filaments-for-spider-web-clock/)
* [GETTING STARTED WITH THE ESP8266 AND DHT22 SENSOR](https://www.losant.com/blog/getting-started-with-the-esp8266-and-dht22-sensor)
* [Here's how to get a more accurate RTC clock set from an NTP time server](https://forum.arduino.cc/index.php?topic=526792.0)

* [NTPtimeESP](https://github.com/SensorsIot/NTPtimeESP)
################################## Junk ########################################




* [Is That A Word Clock In Your Pocket?](https://hackaday.com/2019/02/15/is-that-a-word-clock-in-your-pocket/)
* [Alphanumeric GPS Wall Clock](https://learn.sparkfun.com/tutorials/alphanumeric-gps-wall-clock)
* [In memory of Dali](https://hackaday.io/project/5705-in-memory-of-dali)

* [ESP8266 Tips & Tricks](https://www.youtube.com/channel/UCqk4hT4XpzUVVUfsIDNzvPw)
* [My ESP32 videos](https://www.youtube.com/channel/UCu7_D0o48KbfhpEohoP7YSQ)

* [Impractical Clock Uses Tuning Fork](https://hackaday.com/2019/08/29/impractical-clock-uses-tuning-fork/)

* [EL Wire Neon Nixie Style Clock](https://www.instructables.com/id/EL-Wire-Neon-Nixie-Style-Clock/)

* [Edge-Lit 7-Segments Clock The New Normal](https://hackaday.com/2020/04/14/edge-lit-7-segments-clock-the-new-normal/)

# Enclosure
* [Printed It: Custom Enclosure Generator](https://hackaday.com/2018/03/02/printed-it-custom-enclosure-generator/)

# History of Time
* [A revolution in time](https://aeon.co/essays/when-time-became-regular-and-universal-it-changed-history)

# Horology
Horology is the study of the measurement of time.
In current usage, horology refers mainly to the study of mechanical time-keeping devices,
while chronometry more broadly includes electronic devices that have largely supplanted
mechanical clocks for the best accuracy and precision in time-keeping.

* [Horology](https://en.wikipedia.org/wiki/Horology)
* [tourbillon](https://en.wikipedia.org/wiki/Tourbillon)
* [Jaeger-LeCoultre: Tourbillon watches explained by Jeff Kingston](https://www.youtube.com/watch?v=u7sE3L-V36E)
* [Gyrotourbillion Blesses The Eyes, Hard to Say](https://hackaday.com/2018/06/30/gyrotourbillion-blesses-the-eyes-hard-to-say/)
* [Spiral Exhaust Movement](https://cults3d.com/en/3d-model/various/mouvement-echappement-spiral)
* [3D-printed Watch with Tourbillon](https://www.thingiverse.com/thing:1249221)
    * [3D-printed Watch with Tourbillon - How it's made](https://www.youtube.com/watch?v=Go8woPGOggg&app=desktop)
* [The Clockwerk 3D-Printed Triple-Axis Tourbillon by Adam Wrigley](https://www.youtube.com/watch?v=8KMbHNoY5zc)
* [3D printed mechanical Clock with Anchor Escapement](https://www.thingiverse.com/thing:328569)
* [3D printed mechanical Clock with Anchor Escapement](https://www.thingiverse.com/make:704836)
* [3D-Printed Tourbillon Demo Keeps the Time with Style](https://hackaday.com/2019/02/04/3d-printed-tourbillon-demo-keeps-the-time-with-style/)
* [3D Print a Working Tourbillon Clock](https://makezine.com/projects/3d-printed-tourbillon-clock/)
* [Hawk Eye is a 3D Printed Triple-Axis Tourbillon](https://all3dp.com/hawk-eye-is-a-3d-printed-triple-axis-tourbillon/)
* [3D-Print Triaxial Tourbillon Clock](https://www.thingiverse.com/thing:3415296/)
    * [Jacob & Co. Astronomia Tourbillon Tutorial Video](https://www.youtube.com/watch?v=N861ozj7QYU)
* [How Earth Moves](https://www.youtube.com/watch?v=IJhgZBn-LHg&feature=youtu.be)
* [Time Zone Map](https://www.timeanddate.com/time/map/)
* [Clock (Dual Ulysse Escapement)](https://www.thingiverse.com/thing:3078909)
* [3D printed mechanical Clock with Anchor Escapement (STL files) by ToScH](https://www.thingiverse.com/thing:329975)
* [Ferrofluid Clock Display](https://hackaday.io/project/167056-fetch-a-ferrofluid-display)

* [The Geared Head of Feelings](https://www.thingiverse.com/thing:2670124)

## Precision Time Keeping
If interested in precision timing in general,
consider joining the [Time Nuts email list](https://lists.febo.com/mailman/listinfo/time-nuts_lists.febo.com).

* [100 Year Old Atomic Clock](https://hackaday.com/2019/09/25/100-year-old-atomic-clock/)
* [Cesium Clock Teardown, Or Quantum Physics Playground](https://hackaday.com/2020/03/25/cesium-clock-teardown-or-quantum-physics-playground/)

## Galileo Escapement Mechanism
Galileo's escapement is a design for a clock escapement,
invented around 1637 by Italian scientist Galileo Galilei (1564 - 1642).
It was the earliest design of a pendulum clock.

* [3D Printed Galileo Pendulum](https://www.youtube.com/watch?v=8g-rlaZNAjU)
* [Galileo Wooden Escapement Mechanism](https://www.instructables.com/id/Galileo-Wooden-Escapement-Mechanism/)

## Clepsydra Clock
A water clock or clepsydra is any timepiece by which time is measured by
the regulated flow of liquid into (inflow type) or out from (outflow type) a vessel,
and where the amount is then measured.

* [Steampunk Clepsydra](https://www.instructables.com/id/Steampunk-Clepsydra-Water-Thief-Clock/)

## John Harrison Clock
* [The Clock That Changed the World (BBC History of the World)](https://www.youtube.com/watch?v=T-g27KS0yiY&feature=youtu.be)

# Getting and Keeping Time
* ["Connect" to an atomic clock in space! GPS, DCF77](http://hackaday.io/project/1353)
* [NIST-F1 Cesium Fountain Atomic Clock](https://www.nist.gov/pml/time-and-frequency-division/primary-standard-nist-f1)
* [WWV Radio Station](http://en.wikipedia.org/wiki/WWV_%28radio_station%29)
    * [NIST Radio Stations]()
* [What Will You Do If WWVB Goes Silent?](https://hackaday.com/2018/08/20/what-will-you-do-if-wwvb-goes-silent/)

# Unix Time
* [Epic Clock Clocks The Unix Epoch](https://hackaday.com/2018/09/18/epic-clock-clocks-the-unix-epoch/)
* [End of Time (Unix) - Numberphile](https://www.youtube.com/watch?v=QJQ691PTKsA&feature=youtu.be)

# Time from Mains Frequency
* [Is Your Clock Tied to Mains Frequency?](https://hackaday.com/2018/03/29/ask-hackaday-is-your-clock-tied-to-mains-frequency/)


# Time from Radio Stations
* [WHAT WILL YOU DO IF WWVB GOES SILENT?](https://hackaday.com/2018/08/20/what-will-you-do-if-wwvb-goes-silent/)

# Ham Radio Clock
* [Ham Clock Raspberry Pi](https://dl1gkk.com/ham-clock-raspberry-pi/)


# Dealing with Daylight Savings Time
* [Tricks to get NTP time for the ESP32 and the ESP8266 incl. Summer- and Daylight Saving time](https://www.youtube.com/watch?v=r2UAmBLBBRM&feature=youtu.be)


# Speaking Clocks
* [Retrotechtacular: The Speaking Clock Goes Silent](https://hackaday.com/2019/10/30/retrotechtacular-the-speaking-clock-goes-silent/)

## Pulse Per Second (PPS) Signal from the GPS
A pulse per second (PPS or 1PPS) is an electrical signal that has a width of less than one second and a sharply rising or abruptly falling edge that accurately repeats once per second. PPS signals are output by radio beacons, frequency standards, other types of precision oscillators and some GPS receivers.

* [Why do GPS receivers have a 1 PPS output?](https://electronics.stackexchange.com/questions/30750/why-do-gps-receivers-have-a-1-pps-output)
* [Add GPS Time and Location to a Raspberry Pi Project](https://www.rs-online.com/designspark/add-gps-time-and-location-to-a-raspberry-pi-project)
* [PPS (Pulse per Second) ...simple as that!](https://www.linkedin.com/pulse/pps-pulse-per-second-simple-deepak-kaira/)
* [What’s More Accurate than a GPS Clock? The OpenPPS GPS Clock](https://hackaday.com/2019/05/11/whats-more-accurate-than-a-gps-clock-the-openppc-gps-clock/)
    * [OpenPPS](http://www.rocketmanrc.com/openpps.html)

################################################################################

# Clock + Ticker Board
* [Morphing Digital Clock Will Show You A Good Time](https://hackaday.com/2018/07/10/morphing-digital-clock-will-show-you-a-good-time/)
* [This Incredible High-Speed Ticker Board Mimics Your Motion](https://gizmodo.com/5927488/this-incredible-high-speed-ticker-board-mimics-your-motion)

################################################################################

# Keeping Time
* [Greenwich Mean Time](https://en.wikipedia.org/wiki/Greenwich_Mean_Time)
* [Railway time](https://en.wikipedia.org/wiki/Railway_time)
* [Ruth Belville](https://en.wikipedia.org/wiki/Ruth_Belville)
* [Greenwich Time Signal](https://en.wikipedia.org/wiki/Greenwich_Time_Signal)
* [Greenwich Time Signal - the 'pips'](https://www.bbc.com/historyofthebbc/anniversaries/february/the-pips)

# Time Display

## 7-Segment Display
* [Large Pi-based Thermometer and Clock](https://learn.adafruit.com/large-pi-based-thermometer-and-clock/overview)
* [1.2" 4-Digit 7-Segment Display w/I2C Backpack](https://www.adafruit.com/product/1270)
* [Metro Minimalist Clock](https://learn.adafruit.com/metro-minimalist-clock/overview)
* [7 Segment Display Internet Clock](https://learn.adafruit.com/7-segment-display-internet-clock/code)
* [Not All 7-Segment Displays Are Electronic](https://hackaday.com/2019/10/13/not-all-7-segment-displays-are-electronic/)

## Big Display
* [DIY 7 Segment Digital Clock](https://www.youtube.com/watch?v=1aNHF5tcTpw)
* [DIY Big Clock](https://www.ivanmiranda.com/diy-big-digital-clock)

## Projecting Time on Ceiling
Project of a clock (or other information) on ceiling in bedroom

* [Pocket Projector Uses Raspberry Pi](https://hackaday.com/2018/06/06/pocket-projector-uses-raspberry-pi/)
* [Make Your Own Portable Pocket Sized Pi Zero-Powered Projector](https://www.electromaker.io/blog/article/make-your-own-portable-pocket-sized-pi-zero-powered-projector)
* [Pi Projector](https://www.tindie.com/products/mickmake/pi-projector/)
* [Texas Instruments DLP2000EVM](http://www.ti.com/tool/DLPDLCR2000EVM#0)
* [Christmas Laser Projector](https://hackaday.com/2018/01/22/teardown-christmas-laser-projector/)

## Keeping Time via 60Hz Mains Power
* [Phase-locked Inverter](https://mitxela.com/projects/phase-locked_inverter)

## Split-Flap Display (aka flip-clock)
* [Custom Split-Flap Display Is a Unique Way to Show the Weather](https://hackaday.com/2018/08/18/custom-split-flap-display-is-a-unique-way-to-show-the-weather/)
* [Splitflap](https://scottbez1.github.io/splitflap/)
* [IOT SPLIT-FLAP WEATHER FORECAST POWERED BY XOD](https://www.instructables.com/id/IoT-Split-flap-Weather-Forecast-Powered-by-XOD/)
* [SPLIT FLAP DISPLAY](https://www.instructables.com/id/Split-Flap-Display/)
* [Split-flap display - A 3d printed split-flap display using a 28byj-48 stepper motor](https://hackaday.io/project/163725-split-flap-display)
* [Easy, Modular Alphanumeeric Display are full of Flappy Goodness](https://hackaday.com/2018/02/20/easy-modular-alphanumeric-displays-are-full-of-flappy-goodness/)
* [3D Printed Flip Clock Is Worth A Second Look](https://hackaday.com/2020/02/12/3d-printed-flip-clock-is-worth-a-second-look/)

## Math Clock
Make a Math Wall Clock using e-Paper - https://www.google.com/search?q=math+wall+clock

## Other
* [Tiny Bubbles In The Clock](https://hackaday.com/2019/12/20/tiny-bubbles-in-the-clock/)

################################################################################

# Security
Hyper Text Transfer Protocol Secure (HTTPS) is the secure version of HTTP,
the protocol over which data is sent between your browser and the website that you are connected to.
The 'S' at the end of HTTPS stands for 'Secure'.
It means all communications between your browser and the website are encrypted.

* [How to get HTTPS working on your local development environment in 5 minutes](https://medium.freecodecamp.org/how-to-get-https-working-on-your-local-development-environment-in-5-minutes-7af615770eec)
* [HTTPS for the Internet of Things](https://hackaday.com/2018/10/21/https-for-the-internet-of-things/)
* [How to secure our devices using SSL (ESP8266, ESP32, Tutorial)](https://www.youtube.com/watch?v=Wm1xKj4bKsY)

* [Espressif IoT Development Framework (ESP-IDF)](https://docs.espressif.com/projects/esp-idf/en/latest/index.html)
* [Secure Boot](https://docs.espressif.com/projects/esp-idf/en/latest/security/secure-boot.html)
* [Flash Encryption](https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html)



# Time from GPS
* [GPS Times, Atomic Clock Frequencies, and the Increasing Accuracy of GPS](https://www.allaboutcircuits.com/technical-articles/gps-times-atomic-clock-frequencies-increasing-accuracy-of-gps/)
* [Make a GPS Clock With Arduino](https://www.allaboutcircuits.com/projects/how-to-make-a-gps-clock-with-arduino/)
* [Self-adjusting clock with e-display](https://hackaday.io/project/164955-self-adjusting-clock-with-e-display)

A small GPS breakout board suitable for a clock: [Adafruit Mini GPS PA1010D - UART and I2C - STEMMA QT](https://www.adafruit.com/product/4415)

## Build a Stratum 1 NTP Time Server
* [NIST-F1, a Cesium Fountain Atomic Clock, is the nation's primary time and frequency standard](https://www.nist.gov/pml/time-and-frequency-division/primary-standard-nist-f1)
* [Build Your Own Stratum 1 NTP Time Server with a Raspberry Pi and U-blox NEO-6M](https://www.hackster.io/news/build-your-own-stratum-1-ntp-time-server-with-a-raspberry-pi-and-u-blox-neo-6m-6ce68bcd5752)
* [The Raspberry Pi as a Stratum-1 NTP Server](http://www.satsignal.eu/ntp/Raspberry-Pi-NTP.html)
* [02 Webinar II || GPS & IMU - GPS Time to UTC Epoch Time](https://www.youtube.com/watch?v=24sUlOs8ZGQ&feature=youtu.be&list=PLOafHcC21SxBcup78ZfsHowsVFfHLP-tf)
* [Building a GPS Time Server with the Raspberry Pi 3](http://unixwiz.net/techtips/raspberry-pi3-gps-time.html)
* [Add GPS Time and Location to a Raspberry Pi Project](https://www.rs-online.com/designspark/add-gps-time-and-location-to-a-raspberry-pi-project)
* [The Raspberry Pi as a Stratum-1 NTP Server](http://www.satsignal.eu/ntp/Raspberry-Pi-NTP.html)
* [Stratum-1-Microserver HOWTO](https://www.ntpsec.org/white-papers/stratum-1-microserver-howto/)
* [The Raspberry Pi as a Stratum-1 NTP Server](http://www.satsignal.eu/ntp/Raspberry-Pi-NTP.html)
* [Why You Should Consider Moving From NTP to NTPsec](https://medium.com/linode-cube/why-you-should-consider-moving-from-ntp-to-ntpsec-edab616b6740)
* [Setting the computer time using GPS](https://area-51.blog/2012/06/18/getting-gps-to-work-on-a-raspberry-pi/)
* [5 minute guide to making a GPS Locked Stratum 1 NTP Server with a Raspberry Pi](https://ava.upuaut.net/?p=951)


----

# Objectives
* Clock with hidden functionality (e.g. fan controller)
* Periodic blackout periods for WiFi access (aka turn off WiFi radio to save power)
* Clock should run for as long as possible unplugged, other functions turned off
* [Using the ESP8266 to build the Internet of Things](https://www.youtube.com/watch?v=CjeDkmm0w_w&app=desktop)

# Getting and Keeping Time
* ["Connect" to an atomic clock in space! GPS, DCF77](http://hackaday.io/project/1353)
* [WWV Radio Station](http://en.wikipedia.org/wiki/WWV_%28radio_station%29)
* [What Will You Do If WWVB Goes Silent?](https://hackaday.com/2018/08/20/what-will-you-do-if-wwvb-goes-silent/)

## NTP Server
The NTP acronym stands for [Network Time Protocol][07],
which is an Internet networking communication protocol for clock synchronization
between network clients, operating since 1980’s.
In effect. NTP is a client-server service that can be implemented by
sending or receiving timestamps via UDP requests or by broadcasting / multicasting.
The NTP job is to synchronize all network participants to Coordinated Universal Time (UTC)
within a few milliseconds.
To accomplish this task it uses the [Intersection algorithm][19],
a modification of [Marzullo's algorithm][20],
to estimate accurate time from different noisy sources.
NTP can maintain time with a precision under 50 milliseconds
over the public Internet and under 5 milliseconds in a LAN environment.

The Raspberry Pi operating system gets its time from a NTP server.
In order to interrogate an NTP server, the RPi opens an UDP connection
on a local port and then send and receive UDP packages in the same network with the NTP server.
The packages received are containing multiple information like
UNIX timestamp, accuracy, delay or timezone.
Tools provide friendly methods to extract the data in a pretty objectual format.

A NTP server resides within a hierarchical, semi-layered system of levels of clocks.
See below NTP strata levels:

![ntp-sratum](https://www.geekstips.com/wp-content/uploads/2017/01/1-e1483507016974.jpg)

There are many factors that can affect the accuracy of time synchronized by NTP.
A visible influence can have the following:

* Speed (latency) of the client internet connection.
* Strata of the time server(s) chosen for synchronization.
* Signal distance from the servers (including to and from orbiting satellites).
* The quality and complexity of the software algorithm used.

To have a better accuracy is recommended to choose servers that are physically close
to your exit point (internet provider end point).
This will lessen the chance that the signal is not routed up to a geostationary satellite.

Public server examples:

* Global; www.pool.ntp.org/zone/@
* Asia; www.pool.ntp.org/zone/asia
* Iran; www.pool.ntp.org/zone/ir

Typically, the URL will be something like x.asia.pool.ntp.org where x = 0,1,2 or 3.

Even Google has gotten into the NTP server,
with their claim to fame being [leap-smeared time][54].
They use this technology to smoothly handle leap seconds with no disruptive events.

## Real Time Clock (RTC)
A [real time clock (RTC)][06] is basically just like a watch.
Using a battery, it keeps time for you even when there is a power outage.
The [Adafruit DS1307 Real Time Clock][02] has a battery backup
(CR1220 coin cell battery, keeping time for 5 years or more)
allowing your project to keep track of time even if it is reprogrammed,
or if the power is lost.
I happen to have bought the [kit version][04], which is no long sold by Adafruit.

>**NOTE:**The DS1307 is inexpensive but not a high precision device.
>It may lose or gain up to 2 seconds a day.
>Adafruit also has the [DS3231 Precision RTC][01] ([DS3231 datasheet][12])
>extremely accurate I²C-integrated RTC/TCXO/Crystal, but this is over kill.
>Also, the DS1307 requires 5V power to work.
>If you need a 3.3V-power/logic capable RT, check out our [PCF8523 RTC][03].

Adafruit provides excellent [documentation for using a RTC on a Raspberry Pi][05]
(as well as [how to use the RTC on an Arduino][04]).
The RPi is intended to be connected to the Internet via Ethernet or WiFi,
and time is updated automatically from a [Network Time Protocol (NTP)][07] server
(like the [NIST Internet Time Servers][08]).
The RPi can keep fairly accure time once set,
but the RPi has no internal RTC for when its not connect to the Internet and loses power.
For stand-alone projects with no network connection,
you will not be able to keep the time when the power goes out.

The RPi will communicate with the RTC via
[I²C (Inter-Integrated Circuit)][09], pronounced "I-squared-C",
is a synchronous, master/slave, packet switched serial computer bus.
I2C is a serial protocol for two-wire interface to connect low-speed devices.
[Adafruit has a elementary introduction to I2C][10].

## Internal Clock
A lot of project site tell you to use an RTC for time related projects,
but in this Internet connected age, I don't think they really add value.
The [internal clock of a ESP8266 will drift only 1 or 2 seconds per day][52],
and therefore, if you sync your clock  daily with NTP, you should be fine for most any use.

----

# ESP8266 Clock (Using NTP and without RTC)
* [HackerBoxes 0008: Clockwork](https://www.instructables.com/id/HackerBoxes-0008-Clockwork/)
* [Exact Time without RTC Module for the ESP8266: NTP Time](https://www.youtube.com/watch?v=qzkNXhubWLg)
* [ESP8266 NTP CLOCK](https://www.nutsvolts.com/magazine/article/June2016_ESP8266-NTP-Clock)
* [NodeMCU NTP Digital Clock](https://steps2make.com/2018/01/nodemcu-ntp-digital-clock/)
* [ESP8266, retrieve time from a time server (NTP), elapsed time since last Reset, store time in SPIFFS](https://diyprojects.io/esp8266-web-server-part-3-recover-time-time-server-ntp/#.W-hYPcvYrhO)
* [ESP8266 NTP Clock](https://www.nutsvolts.com/magazine/article/June2016_ESP8266-NTP-Clock)
* [Arduino Time Sync from NTP Server using ESP8266 WiFi module](http://www.geekstips.com/arduino-time-sync-ntp-server-esp8266-udp/)
* [Making a simple ESP8266-based clock synchronized to NIST server](http://embedded-lab.com/blog/making-a-simple-esp8266-internet-clock/)
* [ESP8266 Internet Clock With Weather Update & Many More (No RTC and OTA)](https://www.instructables.com/id/ESP8266-Internet-Clock-With-Weather-Update-Many-Mo/)
* [VFD-tube Clock with ESP32](https://www.elektormagazine.com/news/new-elektor-labs-kit-vfd-tube-clock-with-esp32)
* [NTP Morse Code Clock Powered by ESP8266](https://hackaday.com/2018/12/08/ntp-morse-code-clock-powered-by-esp8266/)


For my ESP8266 clock,
I was my initially inspired by [Andreas Spiess][23] who is a youtube champion of ESP8266/ESP32.
Andreas has posted how to use the [ESP8266 to drive a clock, no RTC required][22],
and when combined this with his approach for
[scheduling a daily task][24] and use of [RTC memory][25],
you get a very interesting platform.

## Establish Arduino IDE Development Environment
In this section, my objective is to get my coding environment,
the Arduino IDE, up in running for my ESP8266 platform.
I'll use a simple program (temperature + humidity sensor read via One-Wire)
to test things out.

### Step 1: Download and Install Arduino IDE - DONE
You can download the Arduino IDE from the [Arduino software website][35].
To get the latest release for Linux 64bit:

```bash
# download the software - arduino-nightly-linux64.tar.xz
# from https://www.arduino.cc/en/Main/Software

# uncompress the tarball, rename the file to its creation date
tar -xvf arduino-nightly-linux64.tar.xz
mv arduino-nightly arduino-Nov-5-2018

# move the result folder to ~/src directory
sudo mv arduino-Nov-5-2018 ~/src

# remove any old version of arduino you may have
cd ~/src
rm -rf arduino-Jan-03-2017
rm ~/bin/arduino

# run the script to install both desktop shortcut and launcher icon
cd ~/src/arduino-Nov-5-2018
chmod +x install.sh
./install.sh
ln -s ~/src/arduino-Nov-5-2018/arduino ~/bin/arduino

# brltty (braille device) which will conflict with the Arduino
sudo apt-get remove brltty
```

When the Arduino Software IDE is properly installed you can execute
the IDE via the command `arduino &>/dev/null &`.

>**NOTE:** Using this method Arduino software won't automatically be updated,
>so you should check Arduino website every few months and download
>a new version if one is available.

### Step 2: Start Arduino IDE and Set Preferences - DONE
Next well start the IDE and set our preferences:

1. Start the Arduino Software IDE via the command `arduino &>/dev/null &`.
2. Open the preferences window from the Arduino IDE.
Go to **File** > **Preferences**
3. On the pop-up, make your **Sketchbook location:** `/home/jeff/src/arduino-Nov-5-2018/sketch-folder`.

### Step 3: Load Needed Libraries - DONE
The ESP8266 addon for the Arduino IDE
is provided by the ESP8266 community.
([lead by Ivan Grokhotkov of Espressif][36]).
Check out the [ESP8266 Arduino GitHub repository][37] for more information.
To see more detailed instructions on installing  ESP8266 support on your Arduino IDE,
see [SparkFun's ESP8266 Thing Hookup Guide][38].
[ESP8266 Arduino libraries documentation][39] can be found online.
Here are the abbreviated installation steps:

1. Start the Arduino Software IDE via the command `arduino &>/dev/null &`.
2. Open the preferences window from the Arduino IDE.
Go to **File** > **Preferences**
3. Enter http://arduino.esp8266.com/stable/package_esp8266com_index.json into
the **Additional Board Manager URLs** field as shown in the figure below. Then, click the **OK** button.
(**NOTE:** If you already have a URL in there, and want to keep it,
you can separate multiple URLs by placing a comma between them.)
4. Navigate to the Board Manager by going to **Tools** > **Board** menu > **Boards Manager**.
There should be a couple new entries in addition to the standard Arduino boards.
Look for ESP8266. Click on that entry, then select **Install**.
5. While your at it, you should repeat steps 2,3 & 4 for the ESP32 (see [arduino-esp32 GitHub][40]).
These libraries are located at https://dl.espressif.com/dl/package_esp32_index.json

For the code below, we'll also need two additional libraries.
You can do this via **Tools** > **Manage Libraries...** > enter "Adafruit Unified Sensors" and install.
Repeat with the filter "DHT sensor" and select "DHT sensor by Adafruit".

### Step 4: Wire-up a ESP8266 - DONE
In my case, I'm using the [NodeMCU DevKit][34]
(a popular version of the NodeMCU v1.0 / ESP-12E board)
manufactured by [HiLetgo][27] and easily obtainable via
[Amazon][28], eBay, or other sources for around $8.79.
Follow the wiring diagram found on the Losant website,
"[Getting Started with ESP8266 and DHT22 Sensor][41]"
and you'll find more information at "[DHT11, DHT22 and AM2302 Sensors][33]".

### Step 5: Load ESP8266 with Software - DONE
With the ESP8266 libraries installed,
all that’s left to do is select your ESP8266 board from the **Tools** > **Board** menu.
So my selection was: **Tools** > **Board** menu > **NodeMCU v1.0 (ESP-12E Module)**.

Next, using a USB cable, plug the NodeMCU into your computer.
Then select your FTDI’s port number under the **Tools** > **Port** menu.
Typically, this will be `/dev/ttyUSB0`.

1. Cut & Paste the code from the Losant site above into the Arduino IDE.
2. Select the check mark icon to verify the code and compile you just entered.
3. Download the code to the ESP8266 via the arrow icon.
4. Select the serial monitor icon on the top right to see the data

-----

# Establish ESP8266/ESP32/Arduino Makefile Development Environment
One of the main reasons why the Arduino boards and the IDE are very popular
with beginners is that it is completely self-contained which makes it very easy to use.
But I'm no beginner and I wish to live with my fimilar tools.
Things like the commandline and `make`.

There are a [verity of options][63],
such as [makeEspArduino][64] and [Esp8266-Arduino-Makefile][72],
and both seem well supported.

>**NOTE:** A more popular choose of makefile tool might be the [Arduino-Makefile][65]
>but I see no support for the ESP processor family, only Arduino.
>A more strategic choose might be to use the CMake tool offered by the
>[Espressif IoT Development Framework (ESP-IDF)][70],
>but that appears to be ESP32 focused and no Arduino.

The makefile can use the ESP/Arduino environment either from the installation
within the Arduino IDE or in a separate git clone of the environment.
In my installation instructions below,
I assume we'll use the Arduino IDE environment already established earlier.

The [Esp8266-Arduino-Makefile README.md file][72] provides the only documentation
but knowing about and reading the documentation for the [Arduino-Makefile][65] is a big help.
What follows was taken from those sources.

## Esp8266-Arduino-Makefile

### Step 1: Install Esp8266-Arduino-Makefile

```bash
# go to where you want to install the repository
cd ~/src

# clone the git repository
git clone https://github.com/thunderace/Esp8266-Arduino-Makefile.git arduino-esp-makefile

# install dependencies for the ardunio makefile
sudo apt-get install libconfig-yaml-perl unzip sed

# install 3rd party tools for the esp processor
cd ~/src/arduino-esp-makefile
chmod +x esp8266-install.sh && ./esp8266-install.sh
chmod +x esp32-install.sh && ./esp32-install.sh
```

>**NOTE:** I believe you can update the esp8266/esp32 tools and libraries by
>simply rerunning the scripts `./esp8266-install.sh` and `./esp32-install.sh`.

### Step 2: Test Your Install
Now lets test the install.
You should get 100% error free feedback from the tests below:

```bash
# for esp8266 - web server
cd ~/src/arduino-esp-makefile/example/esp8266/AdvancedWebServer
make
make clean

# for esp8266 - simple servo motor
cd ~/src/arduino-esp-makefile/example/esp8266/servo
make
make clean

# for esp32 - basic http client
cd ~/src/arduino-esp-makefile/example/esp32/BasicHttpClient
make
make clean

# for esp32 - simple wifi server
cd ~/src/arduino-esp-makefile/example/esp32/SimpleWiFiServer
make
make clean
```

### Step 3: Usage of Esp8266-Arduino-Makefile
You can now create your Makefile for your project.
The approach is very similar to when using [Arduino-Makefile][65].
In your project directory you'll place a Makefile that looks something like this:

```bash
ARDUINO_VARIANT = nodemcu
SERIAL_PORT = /dev/nodemcu
# uncomment and set the right serial baud according to your sketch
#SERIAL_BAUD = 115200
LOG_SERIAL_TO_FILE=yes
USER_DEFINE = -D_SSID_=\"YourSSID\" -D_WIFI_PASSWORD_=\"YourPassword\"
OTA_IP = 192.168.1.184
OTA_PORT = 8266
OTA_AUTH = password

include /home/jeff/src/arduino-esp-makefile/espXArduino.mk
```

See [here][73] for additional examples.
See below for how to run the make tool on the Makefile.

The types of boards supported
* ~/src/arduino-esp-makefile/esp32-1.0.0/boards.txt
* ~/src/arduino-esp-makefile/esp8266-2.4.2/boards.txt

[Documenation on Variables](https://github.com/sudar/Arduino-Makefile/blob/master/arduino-mk-vars.md)

```bash
# print out help information for you makefile
$ make help

Makefile for building Arduino esp8266 and esp32 projects
This file must be included from anaothe Makefile (see README)

Targets available:
  all                  (default) Build the application
  clean                Remove all intermediate build files
  uclean               Remove all intermediate build files except core
  sketch               Build sketch files
  fs                   Build SPIFFS file
  upload               Build and flash the project application
  upload_fs            Build and flash SPIFFS file
  ota                  Build and flash via OTA
                          Params: OAT_IP, OTA_PORT and OTA_AUTH
  term/monitor         Open a the serial console on ESP port
  reset                Reset the board
  print-VAR            Display the makefile VAR content. Replace VAR by the variable name
```




## makeEspArduino
To get what I needed, I ended up settling on on [makeEspArduino][64] as my Makefile.
While not as simple as I wished,
it does seem to be very functional and well supported.
It's major down side is its lack of good documentation.
Only materials I have found are:

* [makeEspArduino: README File](https://github.com/plerup/makeEspArduino/blob/master/README.md)
* [makeEspArduino: A makefile for ESP8266 and ESP32 Arduino projects](https://libraries.io/github/plerup/makeEspArduino)


### Step 1: Install makeEspArduino
Follow the [README file for makeEspArduino][64] to install it on your Linux box.

```bash
# cloning the makeEspArduino repository
cd ~/src
git clone https://github.com/plerup/makeEspArduino.git
```

A description of all available makefile functions
and variables is available via the built-in help command:

```bash
# print out help information
$ make -f ~/src/makeEspArduino/makeEspArduino.mk help

Generic makefile for building Arduino esp8266 and esp32 projects
This file can either be used directly or included from another makefile

The following targets are available:
  all                  (default) Build the project application
  clean                Remove all intermediate build files
  lib                  Build a library with all involved object files
  flash                Build and and flash the project application
  flash_fs             Build and and flash file system (when applicable)
  ota                  Build and and flash via OTA
                         Params: ESP_ADDR, ESP_PORT and ESP_PWD
  ota_fs               Build and and flash file system via OTA
  http                 Build and and flash via http (curl)
                         Params: HTTP_ADDR, HTTP_URI, HTTP_PWD and HTTP_USR
  dump_flash           Dump the whole board flash memory to a file
  restore_flash        Restore flash memory from a previously dumped file
  dump_fs              Extract all files from the flash file system
                         Params: FS_DUMP_DIR
  erase_flash          Erase the whole flash
  list_lib             Show a list of used library files and include paths
Configurable parameters:
  SKETCH               Main source file
                         If not specified the first sketch in current
                         directory will be used.
  LIBS                 Includes in the sketch file of libraries from within
                         the ESP Arduino directories are automatically
                         detected. If this is not enough, define this
                         variable with all libraries or directories needed.
  CHIP                 Set to esp8266 or esp32. Default: 'esp8266'
  BOARD                Name of the target board. Default: 'generic'
                         Use 'list_boards' to get list of available ones
  FLASH_DEF            Flash partitioning info. Default '512K0'
                         Use 'list_flash_defs' to get list of available ones
  BUILD_DIR            Directory for intermediate build files.
                         Default '/tmp/mkESP/HelloServer_generic'
  BUILD_EXTRA_FLAGS    Additional parameters for the compilation commands
  FS_DIR               File system root directory
  UPLOAD_PORT          Serial flashing port name. Default: '/dev/ttyUSB0'
  UPLOAD_SPEED         Serial flashing baud rate. Default: '115200'
  FLASH_FILE           File name for dump and restore flash operations
                          Default: '/tmp/mkESP/HelloServer_generic/esp_flash.bin'
  LWIP_VARIANT         Use specified variant of the lwip library when applicable
                         Default: v2mss536 (v2 Lower Memory)
  VERBOSE              Set to 1 to get full printout of the build
  BUILD_THREADS        Number of parallel build threads
                         Default: Maximum possible, based on number of CPUs

# what esp32 boards are supported
$ make -f ~/src/makeEspArduino/makeEspArduino.mk CHIP=esp32 DEMO=1 list_boards
=== Available boards ===
esp32                ESP32 Dev Module
cw02                 XinaBox CW02
esp32wrover          ESP32 Wrover Module
pico32               ESP32 Pico Kit
esp32thing           SparkFun ESP32 Thing
nina_w10             u-blox NINA-W10 series (ESP32)
esp320               Electronic SweetPeas - ESP320
nano32               Nano32
d32                  LOLIN D32
d32_pro              LOLIN D32 PRO
lolin32              WEMOS LOLIN32
pocket_32            Dongsen Tech Pocket 32
WeMosBat             "WeMos" WiFi&Bluetooth Battery
espea32              ESPea32
quantum              Noduino Quantum
node32s              Node32s
hornbill32dev        Hornbill ESP32 Dev
hornbill32minima     Hornbill ESP32 Minima
firebeetle32         FireBeetle-ESP32
onehorse32dev        Onehorse ESP32 Dev Module
featheresp32         Adafruit ESP32 Feather
mhetesp32devkit      MH ET LIVE ESP32DevKIT
mhetesp32minikit     MH ET LIVE ESP32MiniKit
espino32             ThaiEasyElec's ESPino32
odroid_esp32         ODROID ESP32
heltec_wifi_kit_32   Heltec_WIFI_Kit_32
heltec_wifi_lora_32  Heltec_WIFI_LoRa_32
espectro32           ESPectro32
CoreESP32            Microduino-CoreESP32
alksesp32            ALKS ESP32
wipy3                WiPy 3.0
```

In order to flash your program to the ESP chip,
The [documentation on flashing][67] indicates you can use either a Python utility called [esptool][66]
(a Python utility to communicate with the ROM bootloader and **recommended**)
or you can use [NodeMCU Flasher][68] to program the chip.
The Arduino IDE provides the `esptool` within its libraries (deep within `~/.arduino15/packages`)
and the makeEspArdunio Makefile use it.

To flash the board with your code or SPIFFS filesystem,
you can use the Makefile:

```bash
# compile the code
make -f ~/src/makeEspArduino/makeEspArduino.mk

# flash the the code
make -f ~/src/makeEspArduino/makeEspArduino.mk flash

# flash the spiffs file system
make -f ~/src/makeEspArduino/makeEspArduino.mk flash_fs
```

### Step 2: Test the Installation
Next we'll verify the installation with a quick test.
Attach a ESP8266 or ESP32 board and execute the following commands:

```bash
# enter directory where the make tool is installep
cd ~/src/makeEspArduino

# for test with a esp8266 board
make -f makeEspArduino.mk DEMO=1 flash

# for test with a esp32 board
make -f makeEspArduino.mk CHIP=esp32 DEMO=1 flash
```

If all goes well, the make tool will create a large number of temporary
`.c`, `.cpp`, `.h`, `.o`, files within  `/tmp/mkESP`.
The `.o` object files will be linked together to create an executable in [ELF format][69],
and then flash the ESP via the `esptool`.

### Step X: Building a Project
You can now use the makefile `~/src/makeEspArduino/makeEspArduino.mk`
to build your own sketches or any of the examples in the ESP/Arduino environment.
The makefile will automatically search for a sketch in the current directory and build it if found.
There does seem to be circumstances where this searching mechanism doesn't find libraries or header files.
You'll find some information on the makeEspArduino issue logs on how to solve this problem.


```bash
# A makefile for ESP8266 and ESP32 Arduino projects
# Using https://github.com/plerup/makeEspArduino

# set your current directory
THIS_DIR := $(realpath $(dir $(realpath $(lastword $(MAKEFILE_LIST)))))
ROOT := $(THIS_DIR)/..

# if makeEspArduino doesn't pickup a library or header, put it here
LIBS = $(ESP_LIBS)/SPI \
	$(ESP_LIBS)/Wire \
	$(ESP_LIBS)/ESP8266WiFi \
	$(ESP_LIBS)/ESP8266WebServer \
	$(ESP_LIBS)/DNSServer
LIBS += $(ARDUINO_LIBS)/PersWiFiManager

CHIP = esp8266       # allowed values are 'esp8266', 'esp32', and 'generic'
BOARD = nodemcuv2    # use 'make CHIP=esp8266 DEMO=1 list_boards' to find boards
FS_DIR = ./data      # source directory for SPIFFS filesystem

UPLOAD_PORT = /dev/ttyUSB0
UPLOAD_SPEED = 115200
FLASH_DEF=4M3M


include /home/jeff/src/makeEspArduino/makeEspArduino.mk
```

### Step X: Building a SPIFFS Filesystem
### Step X: Building an Object File Library
### Step X:
### Step X:

----

## Get Clock Display Working
Before creating the software logic for the clock,
lets get the physical wiring established and test it.

### Step X: Load Needed Boards - DONE
Within the Ardiuno IDE,
navigate to the Board Manager by going to **Tools** > **Board** menu > **Boards Manager**.
Look for "esp8266 by ESP8266 Community"
Click on this entry, then select **Install**.

An alternative is is to use the Arduino command line tool, `arduino-cli`,
via the command: `arduino-cli core install esp8266:esp8266`
(Use `arduino-cli core install esp32:esp32` for the ESP32 boards).

### Step 1: Load Needed Libraries - DONE
As you did earlier when setting up your development envirnment, within the Ardiuno IDE,
navigate to the Board Manager by going to **Tools** > **Manage Libraries...**.
Look for "arduino-timer" "Adafruit GFX Library" "Adafruit LED Backpack Library" "Time" "Timezone"
Click on these entries, then select **Install**.

Alternatively, you can use the Arduino command line tool,
`arduino-cli lib install "arduino-timer" "Adafruit GFX Library" "Adafruit LED Backpack Library" "Time" "Timezone"`.
`arduino-cli lib install "DoubleResetDetect"`.

### Step 2: Assembling 7-Segment Display - DONE
I purchased a large 7-segment display from Adafruit ([display][32] + [backpack][31]) for the clock face.
Adafruit provides [detail instructions][30] on how to do the assembly of the components.
Follow these instructions for assembly.

### Step 3: Wiring the 7-Segment Display - DONE
With the physical assembly done, its time to wire the display to the ESP8266.
For this display, Adafruit provides a library writen for the Arduino
but will work with the ESP8266 via its I2C pins.
The I2C bus can be used to connect up to 127 nodes (aka devices)
but only requires two data wires, known as SDA and SCL.

* Connect display's backpack I2C clock pin "C" (SCL) with NodeMCU D1 pin
* Connect display's backpack I2C data pin "D" (SDA) pin with NodeMCU D2 pin
* Connect display's backpack GND pin "-" with with NodeMCU GND
* Connect display's backpack VCC pin "+" with NodeMCU Vin (5V)
* Connect display's backpack pin "IO" with with NodeMCU 3.3V

Once wired, its time to test the NodeMCU + display
and see if it works by running a test program.
I wrote the test program below with the aid of this
[code sample][42], plus the [Adafruit LED Backpacks][43]
and [Adafruit GFX Graphics Library][44] documents.

```cpp
#include <Wire.h>
#include <Adafruit_GFX.h>
#include "Adafruit_LEDBackpack.h"

#define DISPLAY_ADDRESS   0x70  // I2C address of the display

Adafruit_7segment clockDisplay = Adafruit_7segment();  // Create display object
bool blinkColon = false;        // colon on the display turned on (this will be on/off every second)
int displayValue = 0;           // value written to the display


void setup() {
    // Setup Serial port to print debug output
    Serial.begin(9600);
    Serial.println("Clock starting!");

    setBrightness(6);  // set brightness of the display (value 0 to 15, 15 = default = max brightness)

    clockDisplay.begin(DISPLAY_ADDRESS);   // Setup the display
}


void loop() {
  // print the time value to the display
  clockDisplay.print(displayValue, DEC);

  // blink the colon by flipping its value every loop iteration
  blinkColon = !blinkColon;

  // print the colon status value to the display
  clockDisplay.drawColon(blinkColon);

  // Now push out to the display the new values that were set above
  clockDisplay.writeDisplay();

  // for debugging
  Serial.print("displayValue = ");
  Serial.println(displayValue);

  delay(1000);         // pause for 1000 milliseconds = 1 second

  displayValue += 1;   // increase the display value
}
```

## Get Clock Software Logic Working
When using a real-time clock (RTC), you need to provide hardware and logic
to allow manual adjustment of the time.
But if you have Internet access,
you could avoid this by use the Network Time Protocol (NTP) to get time
and use the clock within the ESP8266.

The quickest way to get an date/time from an NTP server is use the native
[NTP Client library provided by the Arduino IDE][26].
I want a NTP client which also includes sensing [Daylight Saving Time (DST)][45]
automatically for [any country][46], or at least [DST for the United States][47].

So I need a NTP client to query a NTP time server (which provides UTC time)
and convert that time to local time, all the while taking into consideration DST.
Luckly, there is exist a nice article on this topic title apparently
["ESP8266 - NTP Client and Daylight Saving Time"][48].
Two libraries are key to make this happen:

* [Arduino Time Library][49] - Here you will find basic time management functions.  It can be used used with: a Real Time Clock, internet NTP time service, GPS time data, and Serial time messages from a computer for time synchronization.
* [Arduino Timezone Library][50] - This library works with Arduino Time Library to convert UTC time to a particular time zone and includes support for Daylight Saving Time.

### Step X: Installing Arduino Library from GitHub - DONE
There are many Arduino libraries supported natively by the Arduino IDE.
If you come across a library you may need on GitHub
(like the Arduino Time Library and the Arduino Timezone Library),
getting it into the Arduino IDE is relatively simple.
Follow these steps (taken from [here][51]:

1. Download the libraries to some temporary space
2. Rename the library, if needed.  The Arduino IDE doesn’t like characters like “_” and “-“.
3. Install the library into the Arduino IDE via **Sketch** > **Include Library** > **Add .ZIP Library...** button.
4. Restart the Arduino IDE.

In my case, this went like this:

```bash
# create your temporary space for the libraries
mkdir ~/Downloads/junk
cd ~/Downloads/junk

# download the libraries (you can do also do this via browser)
wget https://github.com/PaulStoffregen/Time/archive/master.zip -O Time.zip
wget https://github.com/JChristensen/Timezone/archive/master.zip -O Timezone.zip
```

Then perform step 3 & 4 above.

### Step X: Install NTP Client and Test - DONE
* [Tricks to get local NTP time for the ESP32 and the ESP8266 incl. Summer- and Daylight Saving time](https://www.youtube.com/watch?v=r2UAmBLBBRM&t=86s)

Following the article ["ESP8266 - NTP Client and Daylight Saving Time"][48] as a guide,
test out these libraries by installing the ESP8266 the NTP Client found [here][29].

The functionality provide by these libraries should give you all that you need
for getting the correct time information,
but now lets move onto other required functions.

Other ideas
* https://github.com/stelgenhof/NTPClient
* https://github.com/esp8266/Arduino/blob/master/libraries/esp8266/examples/NTP-TZ-DST/NTP-TZ-DST.ino

### Step X:
### Step X:

## Get Timer Interrupt Drive Actions Working
In the above section, we generated updates to the clock display by
timing your loops and adding delay statements.
To get the timing for the delay correct and doing other task is difficult and still keep correct time.
And to top it off, it will not port to a faster processor (e.g. ESP32).
The best way of doing this is to use the ESP8266 internal timer and a callback routine.

There are two types of timers on the ESP8266.
There is os_timer, which is a software based interval timer and the os_timer apparently only has capacity to have seven timers set at one time.  The second type of timer is a hardware based timer, hw_timer, of which there is apparently only one.  We would suggest not to use the hw_timer, as we really don’t know or understand what the ESP8266 libraries are using it for.  You could easily screw up the WiFi, for example.   The documentation for the hw_timer is sparse, at best.  Our example below uses the os_timer.

The [arduino-timer library][53] is part of the Ardunio IDE site of libraries,
and is a simple non-blocking timer library for calling functions **in / at / every** specified units of time.
It supports millis, micros, time rollover, and compile time configurable number of tasks.

### Step X: Install arduino-timer
For the code below, we'll also need an additional library.
You can do this via **Tools** > **Manage Libraries...** > enter "arduino-timer" and install.

### Step X: Test arduino-timer
```cpp
#include <timer.h>

// create a timers with default settings
auto timer1 = timer_create_default();
auto timer2 = timer_create_default();


// print number of milliseconds since processor was booted
bool print_message1(void *) {
    Serial.print("timer1 called at: ");
    Serial.println(millis());

    return true; // repeat? true
}

// print number of milliseconds since processor was booted
bool print_message2(void *) {
    Serial.print("*timer2 called at: ");
    Serial.println(millis());

    return true; // repeat? true
}

void setup() {
    Serial.begin(9600);

    // set the callback print_message function for execution every 1000 millis (1 second)
    timer1.every(1000, print_message1);
    timer2.every(10000, print_message2);
}

void loop() {
    timer1.tick(); // tick the timer
    timer2.tick(); // tick the timer
}
```

### Step X:

## Create the NTP Driven Clock
Now its time to combine the code fragments for the clock display, NTP client, and interrupt timers
to create the foundation for a ESP8266 driven clock.

----

# MQTT
* [Arduino Client for MQTT](https://pubsubclient.knolleary.net/index.html)

## Step X: Install Required Arduino IDE Libraries - DONE
For the code below, we'll also need an additional library.
I want a well supported MQTT publish and subcribe client and [Nick O'Leary code][77] seems to fit the bill.
You can do this via **Tools** > **Manage Libraries...** > enter "PubSubClient" and install.
Better yet, use the Arduino command line tool:
`arduino-cli lib install "PubSubClient"`
(run `arduino-cli lib list` to see the status of the install).

## Step X: Test Library Install and Your Broker
Before proceeding to my ntp-clock code,
I want to make sure the library is properly installed and working with my targeted MQTT broker.
To do this, I used on of the examples that comes with the Adafruit MQTT Library.
I choose [this example code][78].

## Step X:
## Step X:
## Step X:



----



# Adding Alarm Clock Feature
I placed a [rotary encoder][83], specifically the [KY-040 Rotary Encoder][84],
on the back of the case so I could create an alarm feature.
A press of the encoder puts it into "Alarm Set Mode",
turn the knob to set the alarm time, and another press put it back into "Clock" mode.
You'll also need a speaker to make some noise and a button to turn it off.
Finally, add a AM/PM indicator on the clock face.

* [ESP8266 Peripherals: KY-040 Rotary Encoder](https://blog.squix.org/2016/05/esp8266-peripherals-ky-040-rotary-encoder.html)



----


# Over The Air (OTA) Programming
* [ESP8266 Over The Air (OTA) Programming Without Reset Using Arduino IDE (Mac OSX and Windows)](https://www.youtube.com/watch?v=3aB85PuOQhY&t=20s)


----






# SGP30 Air Quality Sensor
This part will measure eCO2 (equivalent calculated carbon-dioxide) concentration within a range of 400 to 60,000 parts per million (ppm), and TVOC (Total Volatile Organic Compound) concentration within a range of 0 to 60,000 parts per billion (ppb).

* https://www.adafruit.com/product/3709
* https://www.adafruit.com/product/3660
* [air quality index (AQI)](https://en.wikipedia.org/wiki/Air_quality_index)
* [Building A Full-Fat Air Quality Monitor](https://hackaday.com/2019/09/03/building-a-full-fat-air-quality-monitor/)



----



# Checkout More Sensors
* [WiFi Sniffer as a Human detector](https://github.com/SensorsIot/Wi-Fi-Sniffer-as-a-Human-detector)
* [Detect When a Device Is Nearby with the ESP8266 Friend Detector](https://null-byte.wonderhowto.com/how-to/detect-when-device-is-nearby-with-esp8266-friend-detector-0188642/)
* [Making a DIY thermal camera based on a Raspberry Pi](https://habr.com/en/post/441050/)



----



# BME280 Temperature, Humidity, and Pressure Sensor
I purchased the [Diymore BME280 Temperature Humidity Barometric Pressure Sensor Module][80].
This [BME280][79], which will work with the [Adafruit BME280 library][81],
is a low power, small size integrated environmental sensor.
The unit combines individual high linearity, high accuracy sensors for pressure, humidity and temperature.
The BME280 sensor measures atmospheric pressure from
300hPa to 1100hPa (±1 hPa absolute accuraccy),
0% to 100% humidity (±3% accuracy)
and -40°C to 85°C temperature (±1.0°C accuracy).
Because pressure changes with altitude, and the pressure measurements are so good,
you can also use it as an altimeter from 0ft to 30Kft (±1 meter accuracy)!

* [Create A Simple ESP8266 Weather Station With BME280](https://lastminuteengineers.com/bme280-esp8266-weather-station/)
* [MAKING A SIMPLE WEATHER WEB SERVER USING ESP8266 AND BME280](http://embedded-lab.com/blog/making-simple-weather-web-server-using-esp8266-bme280/)

### Step 1: Load Needed Libraries - DONE
As you did earlier when setting up your development envirnment, within the Ardiuno IDE,
navigate to the Board Manager by going to **Tools** > **Manage Libraries...**.
Look for " "Adafruit Unified Sensor" and "Adafruit BME280 Library"
Click on this entry, then select **Install**.

Alternatively, you can use the Arduino command line tool,
`arduino-cli lib install "Adafruit BME280 Library" "Adafruit Unified Sensor"`.

### Step X: Wiring BME280 Sensor to ESP8266 NodeMCU
The BME280 module has a two-wire I2C interface for communication.
The default I2C address of the BME280 module is `0x76`
(it can be changed to `0x77` with [this procedure][82]).
The operating voltage of the BME280 module is from 3.3V to 5V.

### Step X:
### Step X:
### Step X:



----




## SPIFFS Filesystem
There are two ways to store data on ESP8266:

* The first is using internal EEPROM which is of 512 Bytes
but you can write data 1 millions of times (no file system).
* The second is use of SPI Flash (64kBytes to 3Mbyte).
In this flash memory ESP stores the program.
Along with program you can store your files on it.
Limitation of this memory is it has only 10000 (ten thousand) write cycles.

The SPI Flash Filing System (SPIFFS)
is a light-weight file system for microcontrollers with an SPI flash chip.
It was designed for SPI flash devices on constrained embedded microprocessor systems with little RAM.

>**NOTE:**
>* Currently, SPIFFS does not support directories.
>It produces a flat structure.
>For example, if SPIFFS is mounted under `/spiffs`,
>then creating a file with path `/spiffs/tmp/myfile.txt`
>will create a file called `/tmp/myfile.txt` in SPIFFS,
>instead of `myfile.txt` under directory `/spiffs/tmp`.
>* It is not a realtime stack.
>One write operation might last much longer than another.
>* Currently, it does not detect or handle bad blocks.

This filing system can be used to store infrequently changing data, such as,
web pages, configurations, sensor calibration data etc.
Even though file system is stored on the same flash chip as the program,
programming new sketch will not modify file system contents.
This allows to use file system to store sketch data, configuration files,
or content for things like Web server.

File system size depends on the flash chip size.
Depending on the board, you have the following [options for flash size][33]:

|      BOARD      | FLASH CHIP SIZE, BYTES | FILE SYSTEM SIZE, BYTES |
|:---------------:|:----------------------:|:-----------------------:|
| Generic module  |          512k          |          64k            |
| Generic module  |          1M            |  64k, 128k, 256k, 512k  |
| Generic module  |          2M            |           1M            |
| Generic module  |          4M            |           3M            |
| Adafruit HUZZAH |          4M            |         1M, 3M          |
| NodeMCU 0.9     |          4M            |         1M, 3M          |
| NodeMCU 1.0     |          4M            |         1M, 3M          |

So the first thing you need to know the size of the flash memory
attached to esp8266 on your module.
Common sizes are 512 kB (4Mbit), 1 MB (8Mbit) and 4 MB.
You can use the [esptool][32] can determine it.

You can choose the size of the SPIFFS in your [flash 'layout'][33]
by selecting the option in the Arduino's IDE Tools menu
or via the esptool. Pick one according to for you flash size
and size of the files you want to put into SPIFFS.

>**NOTE:** If you have 1 MB flash on your module and you want to use OTA upload,
>set flash space for twice a space taken by the sketch.

You can use the Arduino IDE to create and load your SPIFFS filesystem
and you can find instructions here:

* [ESP8266 How to Upload Files to SPIFFS](https://www.youtube.com/watch?v=25eLIdLKgHs)
* [Arduino ESP8266 filesystem uploader](https://github.com/esp8266/arduino-esp8266fs-plugin)

I prefer to use the commandline tools [`esptool.py`][32] and [`mkspiffs`][85]
for my SPIFFS work.
(**NOTE:** There is an alternative to `mkspiffs` called [`spiffsgen.py`][86].)




* [ESP8266 Web Server Files With SPIFFS Flash Memory Using Arduino IDE](https://www.youtube.com/watch?v=pfJROpQg-Is&feature=youtu.be)
* [#121 SPIFFS and JSON to save configurations on an ESP8266](https://www.youtube.com/watch?v=jIOTzaeh7fs)
* [Using ESP8266 SPIFFS](https://www.instructables.com/id/Using-ESP8266-SPIFFS/)
* [ESP8266 Arduino Core: File System](http://esp8266.github.io/Arduino/versions/2.0.0/doc/filesystem.html#flash-layout)
* [Example of ESP8266 Flash File System (SPIFFS)](https://circuits4you.com/2018/01/31/example-of-esp8266-flash-file-system-spiffs/)


### Step X: Install `mkspiffs` - DONE
The tool [`esptool.py`][32] should have been already installed in an earlier step
but we must now install [`mkspiffs`][85].

```bash
# clone the git repository for mkspiffs
cd ~/src
git clone https://github.com/igrr/mkspiffs.git

# update tools used by mkspiffs
cd ~/src/mkspiffs
git submodule update --init

# build the mkspiffs tool
make dist

# put the mkspiffs into your path
mv mkspiffs ~/bin

# check which options were set when building mkspiffs
$ mkspiffs --version
mkspiffs ver. 0.2.3-6-g983970e
Build configuration name: generic
SPIFFS ver. 0.3.7-5-gf5e26c4
Extra build flags: (none)
SPIFFS configuration:
  SPIFFS_OBJ_NAME_LEN: 32
  SPIFFS_OBJ_META_LEN: 0
  SPIFFS_USE_MAGIC: 1
  SPIFFS_USE_MAGIC_LENGTH: 1
  SPIFFS_ALIGNED_OBJECT_INDEX_TABLES: 0

# usage information about mkspiffs
$ mkspiffs --help

USAGE:

   mkspiffs  {-c <pack_dir>|-u <dest_dir>|-l|-i} [-d <0-5>] [-a] [-b
             <number>] [-p <number>] [-s <number>] [--] [--version] [-h]
             <image_file>

Where:

   -c <pack_dir>,  --create <pack_dir>
     (OR required)  create spiffs image from a directory
         -- OR --
   -u <dest_dir>,  --unpack <dest_dir>
     (OR required)  unpack spiffs image to a directory
         -- OR --
   -l,  --list
     (OR required)  list files in spiffs image
         -- OR --
   -i,  --visualize
     (OR required)  visualize spiffs image

   -d <0-5>,  --debug <0-5>
     Debug level. 0 means no debug output.

   -a,  --all-files
     when creating an image, include files which are normally ignored;
     currently only applies to '.DS_Store' files and '.git' directories

   -b <number>,  --block <number>
     fs block size, in bytes

   -p <number>,  --page <number>
     fs page size, in bytes

   -s <number>,  --size <number>
     fs image size, in bytes

   --,  --ignore_rest
     Ignores the rest of the labeled arguments following this flag.

   --version
     Displays version information and exits.

   -h,  --help
     Displays usage information and exits.

   <image_file>
     (required)  spiffs image file
```

### Step X: Preparing Filesystem with `mkspiffs`
`mkspiffs` is a tool to build and unpack SPIFFS images.
The images can be built on you development computer and uploaded during flashing.
`mkspiffs` is used to create image from a given folder.
To do this you need to obtain some parameters:

* **Block Size:** 4096 (standard for SPI Flash)
* **Page Size:** 256 (standard for SPI Flash)
* **Image Size:** Size of the partition in bytes (can be obtained from partition table)
* **Partition Offset:** Starting address of the partition (can be obtained from partition table)

I make heavy use of NodeMCUs, so in this case, to pack a folder
into the typical 1 Megabyte image (your other choose is 3 Megabyte):
`mkspiffs -c [src_folder] -b 4096 -p 256 -s 0x100000 spiffs.bin`.

To flash the image to ESP32 at offset `0x110000`:
`python esptool.py --chip esp32 --port [port] --baud [baud] write_flash -z 0x110000 spiffs.bin`

For my specific example,
I want to flash my `ntp-clock` WiFi credentials into a SPIFFS filesystem.
So I created a directory called `data`,
and created in that directory a file with the information my project needed.
The file I used (`info.json`) is:

```
{
    "personal": {
        "first-name": "Jeff",
        "last-name": "Irland",
        "blog": "http://jeffskinnerbox.me",
        "email": "jeffskinnerbox@yahoo.com",
        "github": "https://github.com/jeffskinnerbox",
        "gravatar": "http://1.gravatar.com/avatar/d6386d1bc80e871a5a4b6d0e28d5f7da.png"
    },
    "device": {
        "model": "HiLetgo New Version ESP8266 NodeMCU LUA CP2102 ESP-12E",
        "mac-address": "???"
    },
    "home-wifi": {
        "ssid": "<my-ssid>",
        "password": "<my-password>"
    },
    "jetpack-wifi": {
        "ssid": "<my-ssid>",
        "password": "<my-password>"
    }
}
```
So for `ntp-clock`, I did the following:

```bash
# create the spiffs filesystem for uploading
mkspiffs -c data/info.json -b 4096 -p 256 -s 0x100000 spiffs.bin

# upload the spiffs filesystem to esp
python esptool.py --chip esp8266 --port /dev/ttyUSB0 --baud 115200 write_flash -z 0x110000 spiffs.bin
```

>**NOTE:** If you get an error saying "SPIFFS_write error(-10001): File system is full",
>this means that your files are too large to fit into the SPIFFS memory.


### Step X: Flashing Filesystem with `esptool`



----



## Support Functions
* [PersWiFiManager](http://ryandowning.net/PersWiFiManager/examples.html)
* [DoubleResetDetector](https://github.com/datacute/DoubleResetDetector/blob/master/examples/minimal/minimal.ino)

* [WiFiManager](https://github.com/tzapu/WiFiManager/tree/development#how-it-works)
* [Avoid Hard-Coding WiFi Credentials on Your ESP8266 Using the WiFiManager Library](https://www.instructables.com/id/Avoid-Hard-Coding-WiFi-Credentials-on-Your-ESP8266/)

So what if you take this clock out of my home and try to connect to another WiFi network?
It doesn't know the password to this new WiFi Access Point (AP).
And updating the firmware with a new SSID & password seems a poor plan.

Well, I'm not the first to face this problem and the ESP community have a solution.
Create another start-up mode where your clock becomes an  WiFi AP,
supply a capture portal via this AP,
provide a webpage where you can input the required credentials,
and store the credentials permanently so on the next boot up these credentials are used.
This special startup mode would occur if you do a double reset on the reset button.

There are two popular libraries that supply this functionality:
[WiFiManager][59] (see [here][60] for WiFiManager tutorial) and
the [Persistent WiFi Manager (PersWiFiManager)][55]
(there is also the [`enduser_setup` module][71] for the NodeMCU which has more feature/polish).
Both are in the Arduino IDE Library Manager
both allow you to avoid hard-coding your WiFi credentials into your code.
The later is superior in that it allows your program to continue functioning normally, even in AP mode.
It is also more memory efficient, as it does not have to dynamically build the page,
and can serve it from [SPIFFS][62] (flash file system created independent of compiler)
rather than [PROGMEM][61] (compile time flash loading).

### Step X: SPIFFSReadServer Web Server
[SPIFFSReadServer](http://ryandowning.net/SPIFFSReadServer/)
is a SPI Flash File System (SPIFFS) server extension of the
ESP8266 Web Server (aka [ESP8266WebServer][58]).
To use it, you put your webpages in SPIFFS file system and
Instead of the declaration `ESP8266WebServer server(80);`
you just replace it with `SPIFFSReadServer server(80);`.


### Step X: WiFi Manager Library (PersWiFiManager)
The [Persistent WiFi Manager (PersWiFiManager)][55]
provides a WiFi web interface to capture settings for ESP8266-based microcontrollers.
The manager auto-connect to the last used WiFi network, and then if unsuccessful,
switch the WiFi to [Access Point (AP)][56] mode with a [captive DNS server][57].
The microcontroller will proceed to the main loop after,
regardless of WiFi connection status.
While AP mode, any browser can connect to the WiFi network to provide configure data,
or general, access the device as a webserver.

### Step X: Server Web Page Within SPIFFS
* [ESP8266 Storing Wi-Fi Settings In Flash Auto-Switch AP/Station Modes](https://www.youtube.com/watch?v=lyoBWH92svk&feature=youtu.be)

### Step X: Double-Reset to Initialize
* https://www.instructables.com/id/Morphing-Digital-Clock/
* https://github.com/hwiguna/HariFun_166_Morphing_Clock/blob/Shared/Latest/MorphingClock/NTPClient.cpp
* part of the arduino library - https://github.com/jenscski/DoubleResetDetect

* [Create A Simple ESP8266 NodeMCU Web Server In Arduino IDE](https://lastminuteengineers.com/creating-esp8266-web-server-arduino-ide/)

Next we want to detects a double reset so that an alternative start-up mode can be used.
In our case, to allow re-configuration of a device's WiFi with SSID / password and set your time zone..

>**NOTE:** The [DoubleResetDetector library][74] provides an alternative implementation that
>replaced SPIFFS implementation with a simpler RTC user memory implementation.
>Here is a [video of DoubleResetDetector][75] but the library I'm using,
>[DoubleResetDetect][76] will appear the same.

Press the reset (RST) button on the ESP twice in a row about one second apart.
The display will show you AP: MorphClk,Pwd: HariFun, and 192.168.4.1.
At this time, the ESP is acting as WiFi access point named MorphClk with password HariFun.
Go to your computer/phone to change your WiFi connection from your normal WiFi to MorphClk.
To switch WiFi, on Windows, the icon is on bottom right corner, on a Mac it's on top right.
You might see a warning saying that your phone cannot find the Internet. It's OK. Your phone is now connected JUST to the ESP and the ESP is not connected to the Internet (yet).
Using a web browser on your computer/phone, visit 192.168.4.1, this is a website being served by the ESP.
Tap "Configure WiFi" and select YOUR WiFi access point and enter your WiFi password. It will then save that information in permanent storage so you will never to enter it again.
This is also where you choose timezone
Use this website to find the TimeZone offset for your location. Don't forget to enter the minus sign.
Enter Y in the 24Hr field to show hours in military format, or enter N if you prefer to 12 hour format. I do not yet have an AM/PM indicator. Maybe you could add that feature and share how you did it?
Don't forget to switch your computer/phone back to your normal WiFi access point or you will not have internet access.

```bash
arduino-cli lib install "arduino-timer" "Adafruit GFX Library" "Adafruit LED Backpack Library" "Time" "Timezone"

arduino-cli lib install "PersWiFiManage@3.0.1"
arduino-cli lib install "ArduinoJson@5.13.4"
arduino-cli lib install "SPIFFSReadServer"

arduino-cli lib install "DoubleResetDetect"
```


### Step X:OTA (Over the Air) Update
OTA (Over the Air) update is the process of loading the firmware to ESP module using Wi-Fi connection rather that a serial port. Such functionality became extremely useful in case of limited or no physical access to the module.

* [Library Makes ESP Over the Air Updates Easy](https://hackaday.com/2019/03/21/library-makes-esp-over-the-air-updates-easy/)
* [ESP8266 - Pushing OTA Upgrades](http://smallbits.marshall-tribe.net/blog/2016/05/29/esp8266-pushing-ota-upgrades)
* https://www.youtube.com/watch?v=o05sBDfaFO8&index=9&list=PLNOffh-6mSoRfxD4wTvRziUDUiSLSyJKE
* https://mongoose-os.com/docs/libraries/remote_management/rpc-service-ota.html
* [Self-updating OTA firmware for ESP8266](https://www.bakke.online/index.php/2017/06/02/self-updating-ota-firmware-for-esp8266/)
* [ESP8266 Arduino Core: OTA Update](http://esp8266.github.io/Arduino/versions/2.0.0/doc/ota_updates/ota_updates.html)
* [ESP8266 OTA Updates with Arduino IDE | Over the Air](https://randomnerdtutorials.com/esp8266-ota-updates-with-arduino-ide-over-the-air/)
* [Search for "Arduino Sketch with OTA Support"](https://www.instructables.com/id/ESP8266-Internet-Clock-With-Weather-Update-Many-Mo/)
* [Over The Air Updates](https://tttapa.github.io/ESP8266/Chap13%20-%20OTA.html)
* [ESP8266 Over The Air (OTA) Programming Without Reset Using Arduino IDE](https://www.youtube.com/watch?v=3aB85PuOQhY&feature=youtu.be)

### Step X:
### Step X:
### Step X:

### Step X: Cryptography
* [PRACTICAL IOT CRYPTOGRAPHY ON THE ESPRESSIF ESP8266](https://hackaday.com/2017/06/20/practical-iot-cryptography-on-the-espressif-esp8266/)



----




# Aggressively Low Power with the ESP8266
* [MAKING THE ESP8266 LOW-POWERED WITH DEEP SLEEP](https://www.losant.com/blog/making-the-esp8266-low-powered-with-deep-sleep)
* [Aggressively Low Power with the ESP8266](https://www.youtube.com/watch?v=I3lJWcRSlUA)
* [Hidden: ESP32 and ESP8266 point-to-point (ESP-Now): Fast and efficient. Comparison with LoRa](https://www.youtube.com/watch?v=6NsBN42B80Q)

# Final Code for NTP-Clock

Every hour, the ESP requests the time from an NTP server. Then it constantly checks for a response, and updates the time if it gets an NTP response. If it hasn't received any responses for over 24 hours, there's something wrong, and the ESP resets itself.

If we miss the first NTP response, timeUNIX will be zero. If that's the case, we send another NTP request (otherwise, the next request would be an hour later, and the temperature logging only starts when the time is known).

We also need to run the server and OTA functions to handle HTTP and OTA requests.

----

# Raspberry Pi Clock
* [How To Set Up Time Synchronization on Ubuntu 16.04](https://www.digitalocean.com/community/tutorials/how-to-set-up-time-synchronization-on-ubuntu-16-04)
* [Setting up the Real-Time Clock on Raspbian Jessie or Stretch](https://spellfoundry.com/sleepy-pi/setting-up-the-real-time-clock-on-raspbian-jessie/)
* [Large Pi-based Thermometer and Clock](https://learn.adafruit.com/large-pi-based-thermometer-and-clock/overview)

Primary sources:

* [Adding a Real Time Clock to Raspberry Pi](https://learn.adafruit.com/adding-a-real-time-clock-to-raspberry-pi/overview)
* [Raspberry Pi: Adding a Real-Time Clock on Raspbian Jessie](https://kd8twg.net/2015/10/29/adding-a-real-time-clock-on-raspbian-jessie/#.W9-n_cvYrhN)
* [Setting up the Real-Time Clock on Raspbian Jessie or Stretch](https://spellfoundry.com/sleepy-pi/setting-up-the-real-time-clock-on-raspbian-jessie/)

## Power Consumption
| Configuration                       | Current Draw | Power     |
|:-----------------------------------:|:------------:|:---------:|
| Raspberry Pi only | | |
| Raspberry Pi + WiFi | | |
| Raspberry Pi + RTC | 0.14A (max 0.29A) | |
| RPi + RTC + 1.2" 7-Segment Display | | |
| | | | |
| ESP8266 only | | |
| ESP8266 + 1.2" 7-Segment Display   | | |

# Raspberry Pi Low Power Operation
 * [Raspberry Pi Zero - Conserve power and reduce draw to 80mA](https://www.jeffgeerling.com/blogs/jeff-geerling/raspberry-pi-zero-conserve-energy)
* [Reducing power consumption of a raspberry Pi](https://bitwizard.nl/wiki/Reducing_power_consumption_of_a_raspberry_Pi)
* [How to reduce power consumption](https://manual.raspberryshake.org/power.html)
* [Raspberry Pi Zero - Conserve power and reduce draw to 30mA](https://declara.com/content/61XZQx25)
* [Powering A Pi From A Battery](https://hackaday.com/2016/05/11/hackaday-prize-entry-powering-a-pi-from-a-battery/)
* [Power Saving Tips for Raspberry Pi](https://babaawesam.com/2014/01/24/power-saving-tips-for-raspberry-pi/)
* [Raspberry Pi2 – Power and Performance Measurement](https://raspi.tv/2015/raspberry-pi2-power-and-performance-measurement)
* [Ethernet disabling in raspberry pi](https://stackoverflow.com/questions/23487728/ethernet-disabling-in-raspberry-pi)

# Measuring Raspberry Pi Power Consumption
* [Measuring the power consumption of the Raspberry P](https://www.youtube.com/watch?v=qG87WmS-Z4Q)
* [PowerJive USB Voltage/Amps Power Meter Tester Multimeter](https://www.amazon.com/PowerJive-Voltage-Multimeter-chargers-capacity/dp/B013FANC9W)
* [How to Monitor Your USB Device Power Usage and Output](https://www.howtogeek.com/228869/how-to-monitor-your-usb-device-power-usage-and-output/)

* [UM34C](https://www.amazon.com/gp/product/B07DMNDT96/)
* Guide Video: https://www.youtube.com/watch?v=3yhHX96h-jg User manual and Android APP download link: http://www.mediafire.com/folder/5c877rc21tp1p/UM34

# Raspberry Pi Power Saving

## Power Off WiFi and BT
* [Powering off WiFi and BT on RPiZW](https://www.raspberrypi.org/forums/viewtopic.php?t=186247)
* [Automatically Reconnecting WiFi on a RaspberryPi](http://alexba.in/blog/2015/01/14/automatically-reconnecting-wifi-on-a-raspberrypi/)
* [Airplane mode and rfkill](https://lwn.net/Articles/677839/)
* [Enable/disable wifi dongle](https://www.raspberrypi.org/forums/viewtopic.php?t=47086)

You can use a utility on Raspbian called `wpa_cli` to status and edit the wireless configuration file `/etc/wpa_supplicant/wpa_supplicant.conf`.

```bash
# get your wifi status
$ sudo wpa_cli status

Selected interface 'wlan0'
bssid=48:5d:36:2e:ee:08
freq=2412
ssid=74LL5
id=0
id_str=home
mode=station
pairwise_cipher=CCMP
group_cipher=CCMP
key_mgmt=WPA2-PSK
wpa_state=COMPLETED
ip_address=192.168.1.224
p2p_device_address=74:da:38:6c:d7:aa
address=74:da:38:6c:d7:aa
uuid=c3cfceee-3949-5a7c-8756-83c9d73510e4
```



### Step 1: Wiring the RTC - DONE
I2C can be used to connect up to 127 nodes via a bus has two data wires, called SCL and SDA.
SCL is the clock line.
It is used to synchronize all data transfers over the I2C bus.
SDA is the data line.
Of course, there is a third wire being ground.
There may also be a 5 volt wire to distribute power to the devices.

>**NOTE:** Both SCL and SDA lines are "open drain" drivers.
>What this means is that the chip can drive its output low, but it cannot drive it high.
>For the line to be able to go high you must provide pull-up resistors to the 5v supply.
>There should be a resistor from the SCL line to the 5v line and another from the SDA line to the 5v line.
>The value of the resistors is not critical.
>Anything from 1800 ohms to 47K ohms used (1.8K, 47K and 10K are common values).
>In the case of the Adafruit DS1207 RTC board, these resistors are already provide on the board.

Wiring the Adafruit DS1207 RTC to the RPi simple:

1. Connect VCC on the RTC to the 5.0V pin of the RPi
1. Connect GND on the RTC to the GND pin of the RPi
1. Connect SDA on the RTC to the SDA pin of the RPi
1. Connect SCL on the RTC to the SCL pin of the RPi

## Step 2: Set Up & Test I2C - DONE
You'll need to set up the Raspberry Pi of I2C, and to do so,
run `sudo raspi-config` and under "Advanced" select "I2C" and turn it on
(see [here][11] for more details).

We'll use `i2cdetect` to scan the I2C bus for devices.
It outputs a table with the list of detected devices on the specified bus
(run `man i2cdetect` for more infomration).

To verify your RTC / RPi wiring, first install the required tools and then run a test:

```bash
# install i2c tools
sudo apt-get install python-smbus i2c-tools

# verify the wiring on i2c port 1
$ sudo i2cdetect -y 1
     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f
00:          -- -- -- -- -- -- -- -- -- -- -- -- --
10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
60: -- -- -- -- -- -- -- -- 68 -- -- -- -- -- -- --
70: -- -- -- -- -- -- -- --

# list of capabilities implemented
$ sudo i2cdetect -F 1
Functionalities implemented by /dev/i2c-1:
I2C                              yes
SMBus Quick Command              yes
SMBus Send Byte                  yes
SMBus Receive Byte               yes
SMBus Write Byte                 yes
SMBus Read Byte                  yes
SMBus Write Word                 yes
SMBus Read Word                  yes
SMBus Process Call               yes
SMBus Block Write                yes
SMBus Block Read                 no
SMBus Block Process Call         no
SMBus PEC                        yes
I2C Block Write                  yes
I2C Block Read                   yes
```

This shows that one I2C addresses are in use – 0x68, but not working yet
(if so, the cell would contain "UU").

>**NOTE: Once you have the Kernel driver running,
>`i2cdetect` will skip over 0x68 and display UU instead,
>this means the Raspberry Pi is reading the RTU!

This command lets you check on the state of the Raspberry Pi time keeping directly:

```bash
# check the status of time/date
$ timedatectl status
      Local time: Mon 2018-11-05 03:32:06 UTC
  Universal time: Mon 2018-11-05 03:32:06 UTC
        RTC time: n/a
       Time zone: Etc/UTC (UTC, +0000)
     NTP enabled: no
NTP synchronized: yes
 RTC in local TZ: no
      DST active: n/a
```

Notice the line "RTC time: n/a".
This is telling you that the RTC isn't setup yet.

### Step 3: Detect the RTC Device - DONE
As stated above, the RTC isn't working with the Raspberry Pi yet.
To add support for the RTC, you must adding a [device tree overlay][14]
(also see [this article][15]).
A Device Tree is a description of the hardware in a system,
and by listing the hardware modules, it usually cause driver modules to be loaded.

Run `sudo vi /boot/config.txt`
to edit the RPi device configuration file
and add the following for the RTC with a DS3231 chip
to the end of the file:

```
# enable DS3231 real time clock
dtoverlay=i2c-rtc,ds3231
```

Save the file and reboot the Raspberry Pi via `sudo reboot`.
Now verify your RTC is seen by the Raspberry Pi.
Run `sudo i2cdetect -y 1` again to see the "UU" show up where "0x68" was before.

```bash
# verify the raspberry pi sees the rtc
$ sudo i2cdetect -y 1
     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f
00:          -- -- -- -- -- -- -- -- -- -- -- -- --
10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
60: -- -- -- -- -- -- -- -- UU -- -- -- -- -- -- --
70: -- -- -- -- -- -- -- --
```

Now check on the state of the Raspberry Pi time keeping:

```bash
# check the status of time/date
$ timedatectl status
      Local time: Mon 2018-11-05 03:36:56 UTC
  Universal time: Mon 2018-11-05 03:36:56 UTC
        RTC time: Mon 2018-11-05 03:36:46
       Time zone: Etc/UTC (UTC, +0000)
     NTP enabled: no
NTP synchronized: no
 RTC in local TZ: no
      DST active: n/a
```

Now the "RTC time:" line has a value, so we know the RTC time is being read by the RPi.

### Step 4: Disable the Fake Hardware Clock - DONE
On Linux machines that don't have a RTC unit,
`fake-hwclock` is a set of scripts to save the kernel's current clock periodically,
including at shutdown.
On top of this, NTP is used to initialize the time and deal with the fake clock "drifting"
while the hardware is halted or rebooting.
`fake-hwclock` stores its time in the file  `/etc/fake-hwclock.data` in
[Coordinated Universal Time (UTC)][17] format.

```bash
# contents of fake-hwclock file
$ cat /etc/fake-hwclock.data
2018-11-05 02:44:15
```

>**NOTE:** It is important to restore time at boot
>so that the system clock keeps at least close to realtime.
>fake-hwclock will stop problems like performing filesystem checks at every boot
>since the system believing it has traveled backward in time to 1970,
>the [beginning of time for Unix][16].
>Even if your using NTP, [you'll want to use fake-hwclock][18].

We need to disable the "fake hwclock" because it interferes with the 'real' hwclock
(see [this article][21] for why).

```bash
# remove the fake-hwclock
sudo apt-get -y remove fake-hwclock
sudo update-rc.d -f fake-hwclock remove
sudo systemctl disable fake-hwclock
```

### Step 5: Enable NTP - DONE
* [Creating a Linux service with systemd](https://medium.com/@benmorel/creating-a-linux-service-with-systemd-611b5c8b91d6)
When you ran the command `timedatectl status` above,
you saw "NTP enabled" is set to "no".
To enable the NTP client on the Raspberry Pi, edit the `/etc/systemd/timesyncd.conf` file.
Append/edit [Time] by add time servers or change the provided ones or uncomment the relevant line:

```bash
  .
  .
[Time]
#Servers=0.debian.pool.ntp.org 1.debian.pool.ntp.org 2.debian.pool.ntp.org 3.debian.pool.ntp.org
Servers=0.us.pool.ntp.org 1.us.pool.ntp.org 2.us.pool.ntp.org 3.us.pool.ntp.org
  .
  .
```

Save and close the file, then start and enable it via:

```bash
# set ntp time
sudo timedatectl set-ntp true

# check status
$ timedatectl status
      Local time: Sat 2018-11-10 02:13:18 UTC
  Universal time: Sat 2018-11-10 02:13:18 UTC
        RTC time: Sat 2018-11-10 02:13:19
       Time zone: Etc/UTC (UTC, +0000)
     NTP enabled: yes
NTP synchronized: yes
 RTC in local TZ: no
      DST active: n/a
```

You can use the `ntpq -p` command to show a list of all the NTP servers you are using
and when they where last checked:

```bash
# NTP servers you are using
$ ntpq -p
     remote           refid      st t when poll reach   delay   offset  jitter
==============================================================================
*ntp-3.jonlight. 66.220.9.122     2 u   58   64    7  151.093   16.490  20.760
+ntp.xtom.com    216.218.192.202  2 u   52   64   17   66.839   40.527  48.146
+12.167.151.1    198.148.79.209   3 u   51   64   17   11.746   41.738  39.473
-ns2.vradns.com. 189.130.244.205  2 u   20   64   37   74.942   55.085  50.186
```

### Step 5: Enable the Hardware Clock - DONE
Now with the fake-hwclock off,
you can start the original 'hardware clock' script.

Run `sudo vi /lib/udev/hwclock-set` and comment out these three lines:

```bash
# this enables the hardware clock
#if [ -e /run/systemd/system ] ; then
#    exit 0
#fi
```

Last thing to do is a `sudo reboot`.

### Step 6: Sync Raspberry Pi Time from RTC
* [Setting up the Real-Time Clock on Raspbian Jessie or Stretch](https://spellfoundry.com/sleepy-pi/setting-up-the-real-time-clock-on-raspbian-jessie/)

When you first plug in the RTC module,
it's going to have the wrong time because it has to be set once.
You can always read the time directly from the RTC with `sudo hwclock -D -r`:

```bash
# read the time directly from the RTC
$ sudo hwclock -r
Fri 09 Nov 2018 03:42:46 UTC  -0.100702 seconds

# read the time directly from the RTC (verbose)
$ sudo hwclock -D -r
hwclock from util-linux 2.25.2
Using the /dev interface to the clock.
Assuming hardware clock is kept in UTC time.
Waiting for clock tick...
/dev/rtc does not have interrupt functions. Waiting in loop for time from /dev/rtc to change
...got clock tick
Time read from Hardware Clock: 2018/11/09 03:41:39
Hw clock time : 2018/11/09 03:41:39 = 1541734899 seconds since 1969
Fri 09 Nov 2018 03:41:39 UTC  -0.099190 seconds
```

You can set the correct time easily.
First run `date` to verify the time is correct.
Plug in Ethernet or WiFi to let the Pi sync the right time from the Internet.
Once that's done, run `sudo hwclock -w` to write the time, and another `sudo hwclock -r` to read the time.

```bash
# get the date/time from the internet
$ date
Fri  9 Nov 03:49:28 UTC 2018

# set the hardware clock
$ sudo hwclock -w

# read the hardware clock
$ sudo hwclock -r
Fri 09 Nov 2018 03:49:46 UTC  -0.409448 seconds
```

### Step X: Reading & Writing to the RTC

### Step X: Set Your Time Zone
The Raspberry Pi will default to the UTC time zone,
as highlighted in the above output.
Consistently using Universal Time can reduces confusion when your infrastructure spans multiple time zones.
If you have different requirements and need to change the time zone,
you can use the timedatectl command to do so.

```bash
# listing of all available time zones
timedatectl list-timezones

# change the time zone to eastern time
sudo timedatectl set-timezone America/New_York

# check status
$ timedatectl status
      Local time: Fri 2018-11-09 21:38:28 EST
  Universal time: Sat 2018-11-10 02:38:28 UTC
        RTC time: Sat 2018-11-10 02:38:28
       Time zone: America/New_York (EST, -0500)
     NTP enabled: yes
NTP synchronized: yes
 RTC in local TZ: no
      DST active: no
 Last DST change: DST ended at
                  Sun 2018-11-04 01:59:59 EDT
                  Sun 2018-11-04 01:00:00 EST
 Next DST change: DST begins (the clock jumps one hour forward) at
                  Sun 2019-03-10 01:59:59 EST
                  Sun 2019-03-10 03:00:00 EDT
```

With the use of something other that UTC, notice how the NTP service provides
information about [Daylight Savings Time (DST)][13].

----



[01]:https://www.adafruit.com/product/3013
[02]:https://www.adafruit.com/product/3296
[03]:https://www.adafruit.com/product/3295
[04]:https://learn.adafruit.com/ds1307-real-time-clock-breakout-board-kit/overview
[05]:https://learn.adafruit.com/adding-a-real-time-clock-to-raspberry-pi
[06]:https://en.wikipedia.org/wiki/Real-time_clock
[07]:https://en.wikipedia.org/wiki/Network_Time_Protocol
[08]:https://tf.nist.gov/tf-cgi/servers.cgi
[09]:https://en.wikipedia.org/wiki/I%C2%B2C
[10]:https://learn.adafruit.com/i2c-addresses?view=all
[11]:https://learn.adafruit.com/adafruits-raspberry-pi-lesson-4-gpio-setup/configuring-i2c
[12]:https://datasheets.maximintegrated.com/en/ds/DS3231.pdf
[13]:https://en.wikipedia.org/wiki/Daylight_saving_time
[14]:https://www.raspberrypi.org/documentation/configuration/device-tree.md
[15]:https://www.mjoldfield.com/atelier/2017/03/rpi-devicetree.html
[16]:https://unix.stackexchange.com/questions/26205/why-does-unix-time-start-at-1970-01-01
[17]:https://en.wikipedia.org/wiki/Coordinated_Universal_Time
[18]:https://superuser.com/questions/1272839/ntp-without-hwclock-save-time-regularily-for-next-reboot
[19]:https://en.wikipedia.org/wiki/Intersection_algorithm
[20]:https://en.wikipedia.org/wiki/Marzullo%27s_algorithm
[21]:https://spellfoundry.com/sleepy-pi/setting-up-the-real-time-clock-on-raspbian-jessie/
[22]:https://www.youtube.com/watch?v=qzkNXhubWLg&t=360s
[23]:http://www.sensorsiot.org/
[24]:https://www.youtube.com/watch?v=BzFM3PWx1rg
[25]:https://www.youtube.com/watch?v=r-hEOL007nw
[26]:https://github.com/arduino-libraries/NTPClient
[27]:https://iprice.ph/hiletgo/
[28]:https://www.amazon.com/gp/product/B010O1G1ES/ref=oh_aui_detailpage_o00_s00?ie=UTF8&psc=1
[29]:https://github.com/RoboUlbricht/arduinoslovakia/tree/master/esp8266/ntp_client
[30]:https://learn.adafruit.com/adafruit-led-backpack/1-2-inch-7-segment-backpack
[31]:https://www.adafruit.com/product/1271
[32]:https://www.adafruit.com/product/1270
[33]:https://learn.adafruit.com/dht/connecting-to-a-dhtxx-sensor
[34]:https://www.amazon.com/HiLetgo-Version-NodeMCU-Internet-Development/dp/B010O1G1ES
[35]:https://www.arduino.cc/en/Main/Software
[36]:https://frightanic.com/iot/interview-ivan-grokhotkov-espressif/
[37]:https://github.com/esp8266/Arduino
[38]:https://learn.sparkfun.com/tutorials/esp8266-thing-hookup-guide/installing-the-esp8266-arduino-addon
[39]:https://arduino-esp8266.readthedocs.io/en/2.4.2/#
[40]:https://github.com/espressif/arduino-esp32
[41]:https://www.losant.com/blog/getting-started-with-the-esp8266-and-dht22-sensor
[42]:https://github.com/adafruit/Adafruit_LED_Backpack/blob/master/examples/clock_sevenseg_ds1307/clock_sevenseg_ds1307.ino
[43]:https://cdn-learn.adafruit.com/downloads/pdf/adafruit-led-backpack.pdf
[44]:https://cdn-learn.adafruit.com/downloads/pdf/adafruit-gfx-graphics-library.pdf
[45]:https://en.wikipedia.org/wiki/Daylight_saving_time
[46]:https://en.wikipedia.org/wiki/Daylight_saving_time_by_country
[47]:https://en.wikipedia.org/wiki/Daylight_saving_time_in_the_United_States
[48]:https://www.arduinoslovakia.eu/blog/2017/7/esp8266---ntp-klient-a-letny-cas?lang=en
[49]:https://github.com/PaulStoffregen/Time
[50]:https://github.com/JChristensen/Timezone
[51]:https://www.baldengineer.com/installing-arduino-library-from-github.html
[52]:https://www.instructables.com/id/TESTED-Timekeeping-on-ESP8266-Arduino-Uno-WITHOUT-/
[53]:https://github.com/contrem/arduino-timer
[54]:https://developers.google.com/time/smear
[55]:http://ryandowning.net/PersWiFiManager/
[56]:https://en.wikipedia.org/wiki/Wireless_access_point
[57]:https://en.wikipedia.org/wiki/Captive_portal
[58]:https://circuits4you.com/2016/12/16/esp8266-web-server-html/
[59]:https://tzapu.com/esp8266-wifi-connection-manager-library-arduino-ide/
[60]:http://www.martyncurrey.com/esp8266-and-the-arduino-ide-part-5-adding-wifimanager/
[61]:https://arduino-esp8266.readthedocs.io/en/latest/PROGMEM.html
[62]:https://arduino-esp8266.readthedocs.io/en/latest/filesystem.html
[63]:https://arduino.stackexchange.com/questions/51542/how-to-compile-arduino-esp8266-32-on-ci-cd-cli-shell-cmd-platform
[64]:https://github.com/plerup/makeEspArduino
[65]:https://github.com/sudar/Arduino-Makefile
[66]:https://github.com/espressif/esptool
[67]:http://nodemcu.readthedocs.io/en/dev/en/flash/
[68]:https://github.com/nodemcu/nodemcu-flasher
[69]:https://en.wikipedia.org/wiki/Executable_and_Linkable_Format
[70]:https://docs.espressif.com/projects/esp-idf/en/latest/get-started/index.html
[71]:https://nodemcu.readthedocs.io/en/master/en/modules/enduser-setup/
[72]:https://github.com/thunderace/Esp8266-Arduino-Makefile
[73]:https://github.com/thunderace/Esp8266-Arduino-Makefile/tree/master/example
[74]:https://github.com/datacute/DoubleResetDetector
[75]:https://www.youtube.com/watch?v=l9Gl1yKvMNg
[76]:https://github.com/jenscski/DoubleResetDetect/tree/master
[77]:https://pubsubclient.knolleary.net/
[78]:https://github.com/knolleary/pubsubclient/tree/master/examples/mqtt_esp8266
[79]:https://www.bosch-sensortec.com/bst/products/all_products/bme280
[80]:https://www.amazon.com/gp/product/B01LETIESU/
[81]:https://github.com/adafruit/Adafruit_BME280_Library
[82]:https://lastminuteengineers.com/bme280-arduino-tutorial/#procedure-to-change-i2c-address
[83]:https://en.wikipedia.org/wiki/Rotary_encoder
[84]:https://blog.squix.org/2016/05/esp8266-peripherals-ky-040-rotary-encoder.html
[85]:https://github.com/igrr/mkspiffs
[86]:https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/storage/spiffs.html
[87]:
[88]:
[89]:
[90]:
